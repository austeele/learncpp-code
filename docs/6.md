# 6 Scope, Duration, and Linkage

## 6.1 Compound statements (blocks)
A compound statement, or a block or block statement, is a group of zero or more statements that is treated by the compiler as if it were a single statement. Blocks can be nested inside other blocks, although functions can't be nested inside other functions. A common use for blocks is in conjunction with if statements. The nesting level or depth is the maximum number of nested blocks you can be inside at any point in the function, including the outer block. Keep the nesting level to 3 or less for readability. Anything longer should be refactored into a function.

## 6.2 User-defined namespaces and the scope resolution
The `namespace` keyword allows you to declare your own user-defined namespaces so that function definitions don't collide.
Scope resolution operator: `::` allows you to look for an identifier in a particular namespace.
Using the scope resolution operator in front of an identifier without providing a namespace name will look for the identifier in the global namespace; for example, `::doSomething();`. This is useful when we're inside another namespace, but want to call the global version of the function.
Namespaces can be nested, and we can call them like `foo::goo::add()`, if goo is nested inside foo.
Can alias namespaces: `namespace active = foo::goo;`
Use namespaces when you write libraries or code that you want to distribute to others.

## 6.3 Local variables
Local variables are defined inside a function. Scope is a compile-time property, so trying to use an identifier out of scope will result in a compile error.
Local variables have block scope, and all variable names within a scope must be unique.
Local variables have automatic storage duration. They are created at the point of definition and destroyed at the end of the block they are defined in.
Local variables have no linkage, meaning that each declaration refers to a unique object. Scope defines where a single declaration can be seen and used, whereas linkage defines whether multiple declarations refer to the same object or not.
Variables should be defined in the most limited scope. This reduces the program complexity because the number of active variables is reduced.
Avoid creating new blocks whose only purpose is to limit the scope of variables. (In such a case, you might be better off creating a function).

## 6.4 Introduction to global variables
Global variables are declared outside of a function. Global variables have file scope and static duration (created when the program starts and destroyed when it ends).
Note that global constant variables must be initialized: `const int g_y {1};` or `constexpr int g_z {2};` are both ok.
Best practice is to avoid using global variables.

## 6.5 Variable shadowing (name hiding)
Variable shadowing, or name hiding, happens when we have a variable inside a nested block with the same name as a variable in an outer block. The variable in the outer block is hidden by the variable in the inner block.
Global variables can be shadowed if the same variable is defined locally. Can access the :: scope operator without a prefix to tell the compiler that we mean the global variable instead of the local one.
Best practice is to avoid variable shadowing.

## 6.6 Internal linkage
Identifier with internal linkage can be seen and used within a single file, but it's not accessible from other files (not exposed to the linker). So if two files have same-named identifiers with internal linkage, those identifiers will be treated as independent.
Make non-constant global variables internal with `static`. Const and constexpr globals have internal linkage by default.
`static` is a storage class specifier, which sets name's linkage and storage duration, but not its scope; other storage class specifiers are `extern` and `mutable`.
Functions have external linkage by default, but can be made internal with `static`.
Summary:
```
// Internal global variables definitions:
static int g_x;          // defines non-initialized internal global variable (zero initialized by default)
static int g_x{ 1 };     // defines initialized internal global variable

const int g_y { 2 };     // defines initialized internal global const variable
constexpr int g_y { 3 }; // defines initialized internal global constexpr variable

// Internal function definitions:
static int foo() {};     // defines internal function
```

## 6.7 External linkage and variable forward declarations
Identifiers with external linkage can be seen and used both from the file in which it is defined, and from other code files via a forward declaraction. Functions and non-constant global variables have external linkage by default.
You can make a constant global variable have external linkage by using the `extern` keyword both in the file that defines the variable and in the file that has the forward declaration.
There is no value in giving constexpr variables external linkage (even though it's technically possible to say `extern constexpr int g_z { 3 };`). This is because constexpr variables cannot be forward declared, since the compiler needs to know the value of the constexpr at compile time. If that value is defined in some other file, the compiler has no visibility on what value was defined in that other file.
Function forward declarations don't need the `extern` keyword because the compiler can tell whether it's a forward declaration or not from whether the body is present. Variables do need the `extern` keyword because otherwise, definitions and forward declarations would look identical.
Summary:
```
// External global variable definitions:
int g_x;                       // defines non-initialized external global variable (zero initialized by default)
extern const int g_x{ 1 };     // defines initialized const external global variable
extern constexpr int g_x{ 2 }; // defines initialized constexpr external global variable

// Forward declarations
extern int g_y;                // forward declaration for non-constant global variable
extern const int g_y;          // forward declaration for const global variable
extern constexpr int g_y;      // not allowed: constexpr variables can't be forward declared
```
Quiz:
Scope: where you can access the variable from within the code
Duration: when the variable is alive
Linkage: can you export the variable to another file
Global variables: global scope (accessed from point of declaration to the end of the file in which they're declared); static duration (created when program started, destroyed when it ends); internal or external linkage via `static` and `extern` keywords

## 6.8 Why (non-const) global variables are evil
1. Values can be changed by any function that is called, and no easy way for programmer to know that this will happen. Makes program state unpredictable. Local variables are safer because other functions cannot affect them directly. Best practice is to declare local variables as close to where they are used as possible to minimize the amount of code you have to look through to understand what the variable does. Makes the program less modular and less flexible, meaning it's harder to understand what it does and harder to reuse parts of the code. Avoid using global variables for decision-point variables that change how the program functions.
1. Initialization order problem. Two initialization phases: (1) static and (2) dynamic. In static initialization phase, global variables with constexpr initializers, including literals, are initialized to those values, and global variables without initializers are zero-initialized. In dynamic initialization, global variables with non-constexpr initializers are initialized. If you initialize variables in the dynamic section that are dependent on the static initialization, you would have problems. Can happen in a single file, or worse, across different files. Avoid dynamic initialization whenever possible because it causes a lot of problems in C++.
Might make sense to use non-const global variables in some limited circumstances, like a log file. Any use of a global variable should meet at least the following two criteria: there should only ever be one of the thing your variable represents in your program, and its use should be ubiquitous throughout your program. But note that even if you think that there's only ever going to be one of something, you might expand the program later (ex: single to multiplayer game).
If you have to use a global variable:
- Prefix with `g`/`g_` or put in a namespace
- Encapsulate the variable within the file it's declared in, and provide global access functions to work with the variable
- Pass in global variable as argument to functions

## 6.9 Sharing global constants across multiple files (using inline variables)
