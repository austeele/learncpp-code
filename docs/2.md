# 2 C++ Basics: Functions and Files

## 2.1 Introduction to functions
A function is a reusable sequence of statements designed to do a particular job.
A function call is an expression that tells the CPU to interrupt the current function and execute another function. Caller is the function initiating the function call, and the callee is the function being called.
Functions are useful because they can be repeatedly called.
Functions can functions that call functions... and so on.
Nested functions are not supported, meaning that functions cannot be defined inside of other functions.
Aside: `foo` is a metasyntactic variable, which essentially means a placeholder name.

## 2.2 Function returning values (value-returning functions)
Function must specify the type to be returned, then return the value with a return statement. When the return statement is executed, the function exits immediately. This is called return by value.
C++ has three defined status codes: 0, EXIT_SUCCESS, and EXIT_FAILURE.
C++ disallows calling the `main` function explicitly. Also define main at the bottom of the code file.
Undefined behavior if a value-returning function doesn't actually return a value.
Main will implicitly return 0 if no return statement is provided, but best practice is to return 0 anyway for consistency with other functions.
Functions can only return a single value.
Best practice is to document what the return value means, since it can be anything.
Good programming practice: DRY (don't repeat yourself)... which is the opposite of WET (write everything twice!)

## 2.3 Void functions (non-value returning functions)
Void means a function does not return a value to the caller.
Void functions do not need a return statement. They can if they want, but it's best practice to avoid adding a return statement to reduce redundancy.
Void functions can't be used in expressions that require a value (for example, when writing output to std::cout).
Void functions are called for their behavior, not their return value. Kind of like buying a car.
Returning a value fronm a void function is a compile error.
A return statement that is not the last statement in a function is called an early return. Early returns can be used in value-returning functions, too.

## 2.4 Introduction to function parameters and arguments
Function parameters are variables used in a function. They are always initialized with a value provided by the caller of the function.
An argument is a value passed from the caller to the function when a function call is made.
When a function is called, parameters of the function are created as variables, and the value of each of the arguments is copied into the matching parameter. This is called pass by value.
The argument passed to a function can be any valid expression.

## 2.5 Introduction to local scope
Function parameters and variables defined within the function body are called local variables.
Variables are created and initialized at the point of definition and destroyed at the end of the function.
Variable lifetime is the time between it's creation and destruction.
The C++ spec actually gives compilers a lot of flexibility to decide when local variables are created and destroyed for optimization reasons. This means a variable could be created earlier or destroyed later.
Variable scope determines where the identifier can be accessed within the source code.
If you have a function with x and y in scope, then call another function which takes x and y as parameters, the scopes do not overlap and the x's and y's are separate.
Best practice: Local variables inside the function body should be defined as close to their first use as reasonable.

## 2.6 Why functions are useful, and how to use them effectively
Functions are useful for organization, reusability, testing (less code to test against), extensibility, and abstraction.
When to use functions?
- Groups of statements that appears more than once in a program should be made into a function
- Code with well-defined set of inputs and outputs is good for function (even if it's only done once)
- Function should perform one and only one task
- If it does too much, refactor into multiple functions

## 2.7 Forward declarations and definitions
Functions must be declared first in the file before they are used, or the compiler will issue an error. There are two ways to fix this: reorder the function definitions, or use a forward declaration. Forward declarations don't need to specify the names of the parameters, only the types, but best practice is to keep the names so you know what the function parameters are without having to locate the function definition. (You can just copy-paste the function header and add a semicolon).
Linker error will result if you never define the function that has a forward declaration.
Forward declaractions can also be used with variables and user-defined types, but they have a different syntax.
What is the difference between a declaration and a definition?
- Definition implements (functions/types) or instantiate (variables) the identifier
  - One Definition Rule (ODR) is a well-known rule in C++:
    1. Within a given file, a function/variable/type/template can only have one definition. Violation causes compiler redefinition error. Example:
    ```
    int main()
    {
        int x;
        int x; // violation of ODR, we've already defined x
    }
    ```
    2. Within a given program, a variable or normal function can only have one definition. Violation likely causes linker to issue a redefinition error.
    3. Types/templates/inline functions/inline variables are allowed to have identical definitions in different files. Violation will cause undefined behavior.
    - Note that functions that share an identifier but have different parameters are considered to be distinct functions
- Declaration tells the compiler about the existence of an identifier and its type information. Examples:
  - `int add(int x, int y); // tells the compiler about this function, but no body!`
  - `int x; // tells the compiler about an integer variable named x`
In C++, all defintions are also declarations, but not all declarations are definitions. For example, a function declaration satisfies the compiler, but not the linker. Declarations that aren't definitions are called pure declarations. Forward declarations are pure declarations.
Note that the ODR doesn't apply to pure declarations, but it's still best to avoid having too many declarations for an identifier to avoid redundancy.

## 2.8 Programs with multiple code files
Do not #include a cpp file into another cpp file because it will cause the preprocessor to insert the contents of the #included file directly rather than treating them as separate files.

## 2.9 Naming collisions and an introduction to namespaces
 