# 0 Introduction to C/C++

## 0.1 Introduction to these tutorials
Tips:
- Practice writing programs, don't just copy/paste
- Investigate when you don't understand any concept that you're typing out
- Learn to find and fix errors

## 0.2 Introduction to programming languages
- Machine language: `10110000 01100001`
    - Machine executes directly
    - Programs are not portable
    - Instructions can be fixed width (like 32b) or variable (x86 architecture)
- Assembly: `mov al, 061h`
    - CPU relies on assembler for translation into machine language
    - Used when performance is critical
    - Not portable
    - Difficult to understand
- High-level languages (like C++): `a = 97`
    - Compilers
        - Reads source code, produces stand-alone executable
            - Can run executable without compiler
    - Interpreters
        - Program that directly executes source code instructions
        - More flexible than compiler, but less efficient
        - Interpreter needed every time the program is run (unlike compiler)
    - Most languages can be compiled or interpreted, but some are traditionally compiled (C, C++, Pascal) while others tend to be interpreted (Perl, Javascript)
    - High-level languages benefits
        - Easier to read and write
        - Require fewer instructions to perform the same tasks
        - Portability: just have to recompile the program to run on a particular type of CPU, don't have to change the program itself

## 0.3 Introduction to C/C++
- 1972 Dennis Ritchie at Bell Telephone Laboratories: C programming language
    - Don't have to rewrite code for each platform, while still giving a lot of control
    - ANSI standardization in 1990 (C90) and 1999 (C99)
- 1979 Bjarne Stroustrup at Bell Labs: C++
    - Object-oriented language
    - Language standards/specifications: C++98, C++03, C++11 (big one), C++14, C++17, C++20
- C/C++ philosophy
    - Trust the programmer
    - Lots of freedom to allow the programmer to do what they want
    - C++ is good for situations requiring high performance and precise control over memory and other resources (video games, real-time systems like transportation and manufacturing, finance, graphics, embedded software, productivity, audio/video processing, AI, and more)

## 0.4 Introduction to C++ development
Development steps:
1. Define the problem
1. Determine how you are going to solve the problem (don't start immediately coding - plan first!). Good programs are straightforward, well-documented, modular, and robust.
1. Write the program
1. Compile the program
1. Link object files
1. Test program
1. Debug, then loop back to compile step until program performs to plan

## 0.5 Introduction to the compiler, linker, and libraries
- Compiler goes through each .cpp file in program and does two things:
    1. Ensure code complies with C++ language rules
    1. Translate C++ source code into a machine language file called an object file
        - Typically named name.o or name.obj, where name is the related .cpp file
- Linker program runs after the compiler and does three things:
    1. Combine all object files into a single executable program
    1. Link library files (precompiled code that has been packaged up for reuse). Think C++ Standard Library and other libraries.
    1. Ensure all cross-file dependencies are resolved properly

## 0.6 Installing an Integrated Development Environment (IDE)
- Good: Visual Studio (Windows), Code::Blocks (Linux or Windows), Xcode (Mac), Eclipse
- Make sure at least C++11 is supported, as that's the minimum standard for modern C++

## 0.7 Compiling your first program
- Project: container holding all source code files, images, data files, etc, that are needed to produce an executable, library, website, etc
    - Saves state for easy restoration
    - Best practice: new project for each new program
- Console project: program can be run from Windows, Linux, or Mac console
- Workspace/solution: container that can hold one or more related projects. Can have multiple projects for a single solution, but best to maintain 1:1 ratio while learning.
- Precompiled headers can improve compilation speed by avoiding redundant compilation that tends to occur in larger projects, but they require extra work to use, and for small projects, it's not worth the effort.
- Difference between compile, build, rebuild, clean, and run/start options
    - Build: compiles all _modified_ code files in the project or workspace/solution, then links the object files into an executable. Does nothing if no code files were changed since the last build.
    - Clean: removes all cached objects and executables so that the next time the project is built, all files will be recompiled and a new executable produced
    - Rebuild: "clean" followed by "build"
    - Compile: recompiles a single code file, regardless of whether it was previously cached. Does NOT invoke linker or produce an executable.
    - Run/start executes the executable from a prior build. Visual Studio invokes "build" before "run" to make sure you're running the latest version of your code.