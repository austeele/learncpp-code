# 4 Fundamental Data Types

## 4.1 Introduction to fundamental data types
A binary digit, or a bit, is the smallest unit of memory which can hold a 0 or 1. Memory is organized into sequential units called memory addresses. Each memory address holds 1 byte of data. A byte is a group of bits that are operated on as a unit. The modern standard is that a byte is composed of 8 sequential bits. (Some older or non-standard machines might have bytes of a different size, but it's not something that you typically have to worry about with modern programming).
Data types tell the compiler how to interpret the contents of memory in some meaningful way.
Fundamental data types are the types for which C++ comes with built-in support.
Note: integral means "like an integer" and is often used as part of the term `integral type`, which includes all the Boolean, characters, enumerated, and integer types. They are so named because they're stored in memory as integers, even though their behaviors might vary. This is distinct from the term `integer`, which is a specific data type that holds non-fractional numbers, such as whole numbers, 0, and negative whole numbers.
Strings are not a fundamental type in C++, but rather a compound type.

## 4.2 Void
Void means no type. Usually see in the context of a function that does not have a return type.

## 4.3 Object sizes and the sizeof operator
An object with n bits can hold 2^n unique values.
C++ only guarantees that each fundamental data type will have a minimum size. However, the actual size of the variables may be different on your machine. Don't assume that variables are larger than the specified minimum size. Objects of fundamental data types are generally extremely fast.
`sizeof` is a unary operator that takes a type or variable and returns its size in bytes.
Types that use less memory are not necessarily faster than types that use more memory. For example, CPUs are often optimized to process data of a certain size most quickly.

## 4.4 Signed integers
Four different fundamental integer types: short int, int, long int, long long int.
Integers are signed by default. Prefer `short s;` over `short int s;` because it makes it harder to make a mistake if you accidentally miss the `short` keyword (doesn't blend in with the `int` type).
Range of a signed number is [-2^(n-1), 2^(n-1) - 1].
Integer overflow happens when we try to store a value that is outside the range of the type. Signed integer overflow leads to undefined behavior. Generally results in a loss of information.
In C++, division with two integers always produces an integer result. Any fractional portion is dropped, not rounded.

## 4.5 Unsigned integers, and why to avoid them
Unsigned integers can only hold non-negative whole numbers. The range for unsigned integers is [0, 2^n - 1]. Unsigned integers are good for systems with little memory.
Unsigned integer overflow results in wraparound behavior.
Don't use unsigned with signed integers.

## 4.6 Fixed-width integers and size_t
C99 defines fixed-width integers which are defined in the stdint.h header as part of the standard library. However, they are not guaranteed to be defined on all architectures and might be slower than a wider type; it's hard to know performance impact without measuring.
Fast and least integers are guaranteed to be defined: `std::int_least8_t` is the smallest signed integer type that's at least 8 bits, and `std::uint_fast16_t` is the fastest unsigned integer type that's at least 16 bits. But not a lot of programmers use these, and because architectures are different, it's possible for the program to exhibit different behavior on different architectures.
Warning: the 8-bit fixed-width integer types are often treated like chars instead of integer values, and this may vary per system. Prefer the 16-bit fixed integral types for most cases. This was due to an oversight in the C++ specification.
Best practices:
- Use int when the size of the integer doesn't matter, like when the number will always git in the range of a 2-byte signed integer (~-32k to 32k)
- Prefer std::int#_t when storing a quantity that needs a guaranteed range
- Prefer std::uint#_t when doing bit manipulation or where well-defined wraparound behavior is required
Avoid:
- Unsigned types for holding quantities
- 8b fixed-width integer types
- fast and least fixed-width types
- Compiler-specific fixed-width integers
`sizeof()` returns a value of the type std::size_t, which is defined as an unsigned integral type and is typically used to represetn the size/length of objects.
`std::size_t` varies in size, and in most systems will be equivalent to the address-width of the application. It's defined to be big enough to hold the size of the largest object creatable in your system in bytes. Any object with a size in bytes larger than the largest integral value size_t can hold is considered ill-formed and will cause a compiler error, as the sizeof operator would not be able to return the size without wrapping around. Some compilers limit the largest creatable object to half the maximum value of `std::size_t`. But in practice, the largest creatable object might be smaller than this amount, depending on how much contiguous memory your computer has available for allocation.

## 4.7 Introduction to scientific notation
Scientific notation: significand x 10^exponent
Digits before the x10^ or e are significant digits, which define the number's precision
Zeros after whole numbers are trimmed, unless there is also a decimal point

## 4.8 Floating point numbers
Three different floating-point types: float, double, and long double. Follows IEEE 754 binary format: float is 4 bytes, double is 8, long double can be equivalent to a double (8), 80b (often padded to 12 bytes), or 16 bytes. Floating point types are always signed. Always include at least one decimal place to h elp the compiler understand that the number is floating-point.
`std::cout` will truncate to 6 digits, and would print `5.0` as `5`. Override the default precision using an `output manipulator` function named `std::setprecision()`, like this: `std::cout << std::setprecision(16); std::cout << 3.33333333333333333333333f << '\n'`, which will output 3.333333253860474 (a float will have less precision than a double). Note that the number is not precise to 16 digits. Precision issues impact any number with too many significant digits, not just fractional numbers. Best practice: favor double over float unless space is at a premium, as the lack of precision in a float will often lead to inaccuracies.
Rounding errors compound. Be wary of using floating-point numbers for comparisons, financial, or currency data.
Inf represents infinity and can be positive or negative. NaN stands for Not a Number, of which there are several different kinds. Both are only available if the compiler uses IEEE 754 for floating-point numbers, otherwise undefined behavior could result. If you see IND, it stands for indeterminate. Best practice: avoid division by 0 altogether, even if your compiler supports it.

## 4.9 Boolean values